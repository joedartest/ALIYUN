<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>search BFPRT - 线性查找算法</title>
<style type="text/css">body {background:#333; color:#eee;}</style>
</head>
<body>


<script type="text/javascript">

//-------------------------------------------------------------------------
// BFPRT算法解决的问题十分经典，即从某n个元素的序列中选出第k大(第k小)的元素
// 通过巧妙的分析，BFPRT可以保证在最坏情况下仍为线性时间复杂度
// 该算法的思想与快速排序思想相似
// 当然，为使得算法在最坏情况下，依然能达到o(n)的时间复杂度，五位算法作者做了精妙的处理。
// 算法步骤：
// 1.将n个元素每5个一组，分成n/5(上界)组
// 2.取出每一组的中位数，任意排序方法，比如插入排序
// 3.递归的调用selection算法查找上一步中所有中位数的中位数，设为x，偶数个中位数的情况下设定为选取中间小的一个
// 4.用x来分割数组，设小于等于x的个数为k，大于x的个数即为n-k
// 5.若i==k，返回x；
//   若i<k，在小于x的元素中递归查找第i小的元素；
//   若i>k，在大于x的元素中递归查找第i-k小的元素
// 终止条件：n=1时，返回的即是i小元素
//-------------------------------------------------------------------------
var SEARCH = (function(){
	return {
		BFPRT : function(){

		}
	}
}());

var result = SEARCH.BFPRT([11,12,13,14,15,16,17],13);
console.log(result);

// var arr = [1,2,3,4,5];
// var arr2 = arr.shift();
// console.log(arr);
// console.log(arr2);

// console.log(parseInt(9/2));

</script>

</body>
</html>